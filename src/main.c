//je travaille sur platformio sur un esp32s3 Wroom 1 N16R8 platform espidf avec le code suivant :
/*
je travaille sur platformio sur un esp32s3 Wroom 1 N16R8 platform espidf

l'écran prend place dans le tableau de bord d'une voiture.

*/


#include <lvgl.h>
#include <math.h>
#include <time.h>
#include <sys/time.h>
#include "esp_bsp.h"
#include "display.h"
#include <esp_log.h>   // Add this line to include the header file that declares ESP_LOGI
#include <driver/i2c.h> // Ajout pour l'I2C
#include <esp_heap_caps.h> // Ajout pour l'allocation dans la PSRAM
#include <esp_psram.h> // Ajout pour les fonctions PSRAM

//#include "icon_battery.c"
//extern const lv_img_dsc_t icon_battery; // If declared in a separate file

// Paramètres de la montre
#define FULL_CANVAS_WIDTH 480
#define FULL_CANVAS_HEIGHT 320

#define CANVAS_WIDTH 300
#define CANVAS_HEIGHT 300
#define CLOCK_RADIUS CANVAS_HEIGHT/2
#define HOUR_HAND_LENGTH CANVAS_HEIGHT/2 - 60
#define MINUTE_HAND_LENGTH CANVAS_HEIGHT/2 -30
#define SECOND_HAND_LENGTH CANVAS_HEIGHT/2 -5
#define LVGL_PORT_ROTATION_DEGREE (90)


// Paramètres I2C pour DS3231
#define I2C_MASTER_SCL_IO 18        // GPIO pour SCL
#define I2C_MASTER_SDA_IO 17        // GPIO pour SDA
#define I2C_MASTER_NUM I2C_NUM_1    // Port I2C
#define I2C_MASTER_FREQ_HZ 100000   // Fréquence I2C (100 kHz)
#define I2C_TIMEOUT_MS 1000
#define DS3231_I2C_ADDR 0x68        // Adresse I2C du DS3231

// Paramètres I2C pour PCF8575
#define PCF8575_I2C_ADDR 0x20 // Adresse I2C par défaut du PCF8575 (A0-A2 à GND)
#define PCF8575_WRITE_ADDR (PCF8575_I2C_ADDR << 1) // Adresse pour écriture
#define PCF8575_READ_ADDR ((PCF8575_I2C_ADDR << 1) | 1) // Adresse pour lecture

// Définir les broches du PCF8575 pour chaque icône (exemple)
#define PCF8575_PIN_BATTERY  0  // P0 pour l'icône batterie
#define PCF8575_PIN_HUILE    1  // P1 pour l'icône huile
#define PCF8575_PIN_FREINR   2  // P2 pour l'icône frein rouge
#define PCF8575_PIN_FREINO   3  // P3 pour l'icône frein orange
#define PCF8575_PIN_DEGIVRE  4  // P4 pour l'icône dégivre
#define PCF8575_PIN_ESSENCE  5  // P5 pour l'icône essence
#define PCF8575_PIN_PHARE    6  // P6 pour l'icône phare
#define PCF8575_PIN_PLEINPHARE 7 // P7 pour l'icône plein phare
#define PCF8575_PIN_CLIGNOTANT 8 // P8 pour l'icône clignotant

// Prototypes des fonctions PCF8575
static esp_err_t pcf8575_init(void);
static esp_err_t pcf8575_write(uint16_t value);
static esp_err_t pcf8575_read(uint16_t *value);



static const char *TAG = "RANCHO_BRD";

// Structure pour stocker les points des aiguilles
typedef struct {
    lv_point_t hour_end;
    lv_point_t minute_end;
    lv_point_t second_end;
} clock_hands_t;

static lv_obj_t *background_canvas;
static lv_color_t *bg_cbuf = NULL; // Buffer pour le canvas de fond
static lv_obj_t *theCanvas;
static lv_color_t *cbuf = NULL; // Pointeur pour le buffer alloué dynamiquement
static lv_obj_t *date_label = NULL; // Étiquette pour le jour du mois
static lv_obj_t *date_window = NULL; // Rectangle pour la fenêtre de date
static int last_day = -1; // Dernier jour affiché (-1 pour forcer la première mise à jour)

/*-----------------------------------------------------------*/

static lv_obj_t *icon_battery_obj;
// Original data in Flash
static const uint8_t icon_battery_map[] = {
    0x1b, 0x0b, 0xfd, 0xff, 	/*Color of index 0*/
    0x11, 0x05, 0xba, 0xff, 	/*Color of index 1*/
    0x06, 0x02, 0x6e, 0xff, 	/*Color of index 2*/
    0x00, 0x00, 0x06, 0xff, 	/*Color of index 3*/
  
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x54, 0x00, 0x00, 0x15, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf4, 0x00, 0x00, 0x2f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x17, 0xf5, 0x11, 0x11, 0x3f, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x47, 0xa8, 0x00, 0x00, 0x7f, 0x81, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x06, 0xa8, 0x00, 0x00, 0x6e, 0x81, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x40, 0x00, 0x00, 0x00, 0x0e, 0x01, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  };

// Global image descriptor
lv_img_dsc_t icon_battery;

// Function to initialize the image in PSRAM
void init_icon_battery(void) {
    // Allocate memory in PSRAM
    uint8_t *psram_data = (uint8_t *)heap_caps_malloc(sizeof(icon_battery_map), MALLOC_CAP_SPIRAM);
    if (psram_data == NULL) {
        ESP_LOGE("ICON", "Failed to allocate PSRAM for icon_battery");
        return;
    }
    // Copy data from Flash to PSRAM
    memcpy(psram_data, icon_battery_map, sizeof(icon_battery_map));
    
    // Initialize the image descriptor
    icon_battery.header.cf = LV_IMG_CF_INDEXED_2BIT;
    icon_battery.header.always_zero = 0;
    icon_battery.header.reserved = 0;
    icon_battery.header.w = 80;
    icon_battery.header.h = 34;
    icon_battery.data_size = sizeof(icon_battery_map);
    icon_battery.data = psram_data;
}

/*-----------------------------------------------------------*/

/*-----------------------------------------------------------*/

static lv_obj_t *icon_huile_obj;
// Original data in Flash
static const uint8_t icon_huile_map[] = {
    0x1b, 0x0b, 0xfd, 0xff, 	/*Color of index 0*/
    0x11, 0x07, 0xba, 0xff, 	/*Color of index 1*/
    0x05, 0x02, 0x66, 0xff, 	/*Color of index 2*/
    0x00, 0x00, 0x05, 0xff, 	/*Color of index 3*/
  
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0xa5, 0x00, 0x00, 0x05, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x01, 0xff, 0xa4, 0x00, 0x1f, 0xff, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x01, 0xd5, 0xbf, 0x80, 0x01, 0xe4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x02, 0xc0, 0x06, 0xc0, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x05, 0xbf, 0x80, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x03, 0x80, 0x01, 0xd0, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x01, 0x6f, 0x95, 0x80, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x07, 0x40, 0x01, 0xe5, 0x56, 0xf5, 0x55, 0x50, 0x00, 0x5b, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x07, 0xd4, 0x01, 0xff, 0xff, 0xbf, 0xff, 0xf4, 0x1a, 0xf9, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x01, 0xbe, 0x41, 0xd0, 0x00, 0x00, 0x00, 0x1e, 0xfa, 0x42, 0xd0, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x06, 0xfa, 0xc0, 0x00, 0x00, 0x00, 0x07, 0x50, 0x07, 0x40, 0x01, 0xd0, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x5b, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x01, 0xd0, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x01, 0xd0, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x02, 0xe0, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x00, 0x07, 0xf4, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x40, 0x00, 0x02, 0xe0, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x01, 0x50, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfa, 0xaa, 0xaa, 0xaa, 0xaa, 0xe4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  };

// Global image descriptor
lv_img_dsc_t icon_huile;

// Function to initialize the image in PSRAM
void init_icon_huile(void) {
    // Allocate memory in PSRAM
    uint8_t *psram_data = (uint8_t *)heap_caps_malloc(sizeof(icon_huile_map), MALLOC_CAP_SPIRAM);
    if (psram_data == NULL) {
        ESP_LOGE("ICON", "Failed to allocate PSRAM for icon_huile");
        return;
    }
    // Copy data from Flash to PSRAM
    memcpy(psram_data, icon_huile_map, sizeof(icon_huile_map));
    
    // Initialize the image descriptor
    icon_huile.header.cf = LV_IMG_CF_INDEXED_2BIT;
    icon_huile.header.always_zero = 0;
    icon_huile.header.reserved = 0;
    icon_huile.header.w = 80;
    icon_huile.header.h = 34;
    icon_huile.data_size = sizeof(icon_huile_map);
    icon_huile.data = psram_data;
}

/*-----------------------------------------------------------*/

/*-----------------------------------------------------------*/

static lv_obj_t *icon_freinR_obj;
// Original data in Flash
static const uint8_t icon_freinR_map[] = {
    0x1b, 0x0b, 0xfd, 0xff, 	/*Color of index 0*/
    0x12, 0x06, 0xbd, 0xff, 	/*Color of index 1*/
    0x05, 0x02, 0x64, 0xff, 	/*Color of index 2*/
    0x00, 0x00, 0x09, 0xff, 	/*Color of index 3*/
  
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0xd1, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0xe7, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xc0, 0x00, 0x00, 0x1f, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x00, 0x01, 0xba, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x07, 0xd0, 0xbd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x1f, 0x01, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x7c, 0x07, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0xb4, 0x1d, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0xd0, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xaa, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x1f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x1e, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x34, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x90, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x06, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x01, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xb8, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x78, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0xbd, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0xab, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  };

// Global image descriptor
lv_img_dsc_t icon_freinR;

// Function to initialize the image in PSRAM
void init_icon_freinR(void) {
    // Allocate memory in PSRAM
    uint8_t *psram_data = (uint8_t *)heap_caps_malloc(sizeof(icon_freinR_map), MALLOC_CAP_SPIRAM);
    if (psram_data == NULL) {
        ESP_LOGE("ICON", "Failed to allocate PSRAM for icon_freinR");
        return;
    }
    // Copy data from Flash to PSRAM
    memcpy(psram_data, icon_freinR_map, sizeof(icon_freinR_map));
    
    // Initialize the image descriptor
    icon_freinR.header.cf = LV_IMG_CF_INDEXED_2BIT;
    icon_freinR.header.always_zero = 0;
    icon_freinR.header.reserved = 0;
    icon_freinR.header.w = 80;
    icon_freinR.header.h = 34;
    icon_freinR.data_size = sizeof(icon_freinR_map);
    icon_freinR.data = psram_data;
}

/*-----------------------------------------------------------*/

/*-----------------------------------------------------------*/

static lv_obj_t *icon_freinO_obj;
// Original data in Flash
static const uint8_t icon_freinO_map[] = {
    0x02, 0x9e, 0xfe, 0xff, 	/*Color of index 0*/
    0x01, 0x75, 0xbd, 0xff, 	/*Color of index 1*/
    0x00, 0x3b, 0x64, 0xff, 	/*Color of index 2*/
    0x00, 0x05, 0x09, 0xff, 	/*Color of index 3*/
  
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0xd1, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0xe7, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xc0, 0x00, 0x00, 0x1f, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x00, 0x01, 0xba, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x07, 0xd0, 0xbd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x1f, 0x01, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x7c, 0x07, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0xb4, 0x1d, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0xd0, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xaa, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x1f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x1e, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x34, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x90, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x03, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x01, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xb8, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x78, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0xbd, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0xab, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  };

// Global image descriptor
lv_img_dsc_t icon_freinO;

// Function to initialize the image in PSRAM
void init_icon_freinO(void) {
    // Allocate memory in PSRAM
    uint8_t *psram_data = (uint8_t *)heap_caps_malloc(sizeof(icon_freinO_map), MALLOC_CAP_SPIRAM);
    if (psram_data == NULL) {
        ESP_LOGE("ICON", "Failed to allocate PSRAM for icon_freinO");
        return;
    }
    // Copy data from Flash to PSRAM
    memcpy(psram_data, icon_freinO_map, sizeof(icon_freinO_map));
    
    // Initialize the image descriptor
    icon_freinO.header.cf = LV_IMG_CF_INDEXED_2BIT;
    icon_freinO.header.always_zero = 0;
    icon_freinO.header.reserved = 0;
    icon_freinO.header.w = 80;
    icon_freinO.header.h = 34;
    icon_freinO.data_size = sizeof(icon_freinO_map);
    icon_freinO.data = psram_data;
}

/*-----------------------------------------------------------*/

/*-----------------------------------------------------------*/

static lv_obj_t *icon_degivre_obj;
// Original data in Flash
static const uint8_t icon_degivre_map[] = {
    0x02, 0x9f, 0xfe, 0xff, 	/*Color of index 0*/
    0x01, 0x7f, 0xce, 0xff, 	/*Color of index 1*/
    0x00, 0x50, 0x83, 0xff, 	/*Color of index 2*/
    0x00, 0x05, 0x0a, 0xff, 	/*Color of index 3*/
  
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x66, 0x66, 0x66, 0x66, 0x66, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xab, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x06, 0x03, 0x02, 0x40, 0x01, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x1b, 0x07, 0x87, 0x80, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0f, 0x4b, 0x8b, 0xc0, 0x01, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x03, 0x82, 0x80, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x03, 0x41, 0x81, 0xd0, 0x01, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x02, 0x41, 0xc1, 0xd0, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x42, 0x81, 0xc0, 0x01, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0e, 0x0b, 0x47, 0x40, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x1c, 0x0d, 0x0a, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x44, 0x68, 0x5e, 0x1e, 0x11, 0x13, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x4b, 0x57, 0x93, 0x94, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x41, 0xc1, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x42, 0x81, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x42, 0x42, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  };

// Global image descriptor
lv_img_dsc_t icon_degivre;

// Function to initialize the image in PSRAM
void init_icon_degivre(void) {
    // Allocate memory in PSRAM
    uint8_t *psram_data = (uint8_t *)heap_caps_malloc(sizeof(icon_degivre_map), MALLOC_CAP_SPIRAM);
    if (psram_data == NULL) {
        ESP_LOGE("ICON", "Failed to allocate PSRAM for icon_degivre");
        return;
    }
    // Copy data from Flash to PSRAM
    memcpy(psram_data, icon_degivre_map, sizeof(icon_degivre_map));
    
    // Initialize the image descriptor
    icon_degivre.header.cf = LV_IMG_CF_INDEXED_2BIT;
    icon_degivre.header.always_zero = 0;
    icon_degivre.header.reserved = 0;
    icon_degivre.header.w = 80;
    icon_degivre.header.h = 34;
    icon_degivre.data_size = sizeof(icon_degivre_map);
    icon_degivre.data = psram_data;
}

/*-----------------------------------------------------------*/

/*-----------------------------------------------------------*/

static lv_obj_t *icon_essence_obj;
// Original data in Flash
static const uint8_t icon_essence_map[] = {
    0x02, 0x9e, 0xfe, 0xff, 	/*Color of index 0*/
    0x01, 0x82, 0xd2, 0xff, 	/*Color of index 1*/
    0x00, 0x39, 0x60, 0xff, 	/*Color of index 2*/
    0x00, 0x04, 0x09, 0xff, 	/*Color of index 3*/
  
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x55, 0x55, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xff, 0xff, 0x47, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfa, 0xaa, 0xbf, 0x87, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd4, 0x00, 0x07, 0x82, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd0, 0x00, 0x07, 0x80, 0xbe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x07, 0x80, 0x3f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd0, 0x00, 0x07, 0x80, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x07, 0x80, 0x1f, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd0, 0x00, 0x07, 0x80, 0x0b, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd1, 0x11, 0x17, 0x90, 0x0b, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xbb, 0xbf, 0xf8, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xfe, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd5, 0x55, 0x57, 0x9f, 0x47, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd0, 0x00, 0x07, 0x8b, 0x43, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x07, 0x8b, 0x42, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd0, 0x00, 0x07, 0x8b, 0x42, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x07, 0x8b, 0x41, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd0, 0x00, 0x07, 0x8b, 0x41, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x07, 0x8b, 0x41, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd0, 0x00, 0x07, 0x8b, 0x40, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x07, 0x8b, 0x40, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd0, 0x00, 0x07, 0x8b, 0x40, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x07, 0x87, 0x85, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd0, 0x00, 0x07, 0x86, 0xff, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x07, 0x80, 0xae, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xd1, 0x11, 0x17, 0x90, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xf4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xaa, 0xaa, 0xaa, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x44, 0x44, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  };

// Global image descriptor
lv_img_dsc_t icon_essence;

// Function to initialize the image in PSRAM
void init_icon_essence(void) {
    // Allocate memory in PSRAM
    uint8_t *psram_data = (uint8_t *)heap_caps_malloc(sizeof(icon_essence_map), MALLOC_CAP_SPIRAM);
    if (psram_data == NULL) {
        ESP_LOGE("ICON", "Failed to allocate PSRAM for icon_essence");
        return;
    }
    // Copy data from Flash to PSRAM
    memcpy(psram_data, icon_essence_map, sizeof(icon_essence_map));
    
    // Initialize the image descriptor
    icon_essence.header.cf = LV_IMG_CF_INDEXED_2BIT;
    icon_essence.header.always_zero = 0;
    icon_essence.header.reserved = 0;
    icon_essence.header.w = 80;
    icon_essence.header.h = 34;
    icon_essence.data_size = sizeof(icon_essence_map);
    icon_essence.data = psram_data;
}

/*-----------------------------------------------------------*/

/*-----------------------------------------------------------*/

static lv_obj_t *icon_phare_obj;
// Original data in Flash
static const uint8_t icon_phare_map[] = {
    0xf4, 0xfe, 0x03, 0xff, 	/*Color of index 0*/
    0xad, 0xb5, 0x01, 0xff, 	/*Color of index 1*/
    0x67, 0x6c, 0x00, 0xff, 	/*Color of index 2*/
    0x09, 0x0a, 0x00, 0xff, 	/*Color of index 3*/
  
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0xba, 0xe0, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xd0, 0xb1, 0xa0, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0xff, 0xe0, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe5, 0xbc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x40, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x02, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x34, 0x00, 0x01, 0xc1, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x34, 0x00, 0x01, 0xc2, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x03, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xd5, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x6f, 0x90, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  };

// Global image descriptor
lv_img_dsc_t icon_phare;

// Function to initialize the image in PSRAM
void init_icon_phare(void) {
    // Allocate memory in PSRAM
    uint8_t *psram_data = (uint8_t *)heap_caps_malloc(sizeof(icon_phare_map), MALLOC_CAP_SPIRAM);
    if (psram_data == NULL) {
        ESP_LOGE("ICON", "Failed to allocate PSRAM for icon_phare");
        return;
    }
    // Copy data from Flash to PSRAM
    memcpy(psram_data, icon_phare_map, sizeof(icon_phare_map));
    
    // Initialize the image descriptor
    icon_phare.header.cf = LV_IMG_CF_INDEXED_2BIT;
    icon_phare.header.always_zero = 0;
    icon_phare.header.reserved = 0;
    icon_phare.header.w = 80;
    icon_phare.header.h = 34;
    icon_phare.data_size = sizeof(icon_phare_map);
    icon_phare.data = psram_data;
}

/*-----------------------------------------------------------*/

/*-----------------------------------------------------------*/

static lv_obj_t *icon_pleinPhare_obj;
// Original data in Flash
static const uint8_t icon_pleinPhare_map[] = {
    0xfe, 0x0d, 0x05, 0xff, 	/*Color of index 0*/
    0xc9, 0x09, 0x03, 0xff, 	/*Color of index 1*/
    0x77, 0x03, 0x01, 0xff, 	/*Color of index 2*/
    0x0d, 0x00, 0x00, 0xff, 	/*Color of index 3*/
  
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0xaa, 0xa9, 0x07, 0xff, 0xe9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0xee, 0xa9, 0x0b, 0x55, 0xaf, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x01, 0xb9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x1f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0xee, 0xe8, 0x1c, 0x00, 0x00, 0x02, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0xa6, 0xa4, 0x28, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x28, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0xff, 0xf4, 0x28, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0xa6, 0x64, 0x28, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x54, 0x50, 0x28, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0xff, 0xf8, 0x28, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x55, 0x54, 0x1d, 0x00, 0x00, 0x07, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x50, 0x0a, 0x00, 0x05, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0xff, 0xfd, 0x0b, 0xaa, 0xbf, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x55, 0x06, 0xaa, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  };

// Global image descriptor
lv_img_dsc_t icon_pleinPhare;

// Function to initialize the image in PSRAM
void init_icon_pleinPhare(void) {
    // Allocate memory in PSRAM
    uint8_t *psram_data = (uint8_t *)heap_caps_malloc(sizeof(icon_pleinPhare_map), MALLOC_CAP_SPIRAM);
    if (psram_data == NULL) {
        ESP_LOGE("ICON", "Failed to allocate PSRAM for icon_pleinPhare");
        return;
    }
    // Copy data from Flash to PSRAM
    memcpy(psram_data, icon_pleinPhare_map, sizeof(icon_pleinPhare_map));
    
    // Initialize the image descriptor
    icon_pleinPhare.header.cf = LV_IMG_CF_INDEXED_2BIT;
    icon_pleinPhare.header.always_zero = 0;
    icon_pleinPhare.header.reserved = 0;
    icon_pleinPhare.header.w = 80;
    icon_pleinPhare.header.h = 34;
    icon_pleinPhare.data_size = sizeof(icon_pleinPhare_map);
    icon_pleinPhare.data = psram_data;
}

/*-----------------------------------------------------------*/

/*-----------------------------------------------------------*/

static lv_obj_t *icon_clignotant_obj;
// Original data in Flash
static const uint8_t icon_clignotant_map[] = {
    0xf4, 0xfe, 0x02, 0xff, 	/*Color of index 0*/
    0xb3, 0xba, 0x01, 0xff, 	/*Color of index 1*/
    0x55, 0x59, 0x00, 0xff, 	/*Color of index 2*/
    0x02, 0x02, 0x00, 0xff, 	/*Color of index 3*/
  
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x06, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xbf, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0xee, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xd7, 0xd5, 0x55, 0x00, 0x01, 0x55, 0x57, 0x97, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x43, 0xff, 0xff, 0x40, 0x02, 0xff, 0xff, 0x82, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7d, 0x01, 0x55, 0x5b, 0x40, 0x02, 0xe5, 0x55, 0x40, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x00, 0x00, 0x07, 0x40, 0x02, 0xc0, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x07, 0xd0, 0x00, 0x00, 0x07, 0x40, 0x02, 0x80, 0x00, 0x00, 0x0b, 0x80, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x0b, 0xd0, 0x00, 0x00, 0x07, 0x40, 0x02, 0x80, 0x00, 0x00, 0x07, 0xd0, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0xe4, 0x00, 0x00, 0x07, 0x40, 0x02, 0x80, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x01, 0x11, 0x17, 0x40, 0x02, 0xd4, 0x44, 0x40, 0x7d, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x43, 0xff, 0xff, 0x40, 0x02, 0xff, 0xff, 0x81, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x87, 0x95, 0x55, 0x00, 0x01, 0x55, 0x5b, 0x87, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe7, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0xee, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x40, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  };

// Global image descriptor
lv_img_dsc_t icon_clignotant;

// Function to initialize the image in PSRAM
void init_icon_clignotant(void) {
    // Allocate memory in PSRAM
    uint8_t *psram_data = (uint8_t *)heap_caps_malloc(sizeof(icon_clignotant_map), MALLOC_CAP_SPIRAM);
    if (psram_data == NULL) {
        ESP_LOGE("ICON", "Failed to allocate PSRAM for icon_clignotant");
        return;
    }
    // Copy data from Flash to PSRAM
    memcpy(psram_data, icon_clignotant_map, sizeof(icon_clignotant_map));
    
    // Initialize the image descriptor
    icon_clignotant.header.cf = LV_IMG_CF_INDEXED_2BIT;
    icon_clignotant.header.always_zero = 0;
    icon_clignotant.header.reserved = 0;
    icon_clignotant.header.w = 80;
    icon_clignotant.header.h = 34;
    icon_clignotant.data_size = sizeof(icon_clignotant_map);
    icon_clignotant.data = psram_data;
}

/*-----------------------------------------------------------*/











void update_dashboard_icons(uint16_t pcf8575_state) {
    // Activer ou désactiver les icônes en fonction des bits du PCF8575
    if (pcf8575_state & (1 << PCF8575_PIN_BATTERY)) {
        lv_obj_clear_flag(icon_battery_obj, LV_OBJ_FLAG_HIDDEN);
    } else {
        lv_obj_add_flag(icon_battery_obj, LV_OBJ_FLAG_HIDDEN);
    }
    if (pcf8575_state & (1 << PCF8575_PIN_HUILE)) {
        lv_obj_clear_flag(icon_huile_obj, LV_OBJ_FLAG_HIDDEN);
    } else {
        lv_obj_add_flag(icon_huile_obj, LV_OBJ_FLAG_HIDDEN);
    }
    if (pcf8575_state & (1 << PCF8575_PIN_FREINR)) {
        lv_obj_clear_flag(icon_freinR_obj, LV_OBJ_FLAG_HIDDEN);
    } else {
        lv_obj_add_flag(icon_freinR_obj, LV_OBJ_FLAG_HIDDEN);
    }
    if (pcf8575_state & (1 << PCF8575_PIN_FREINO)) {
        lv_obj_clear_flag(icon_freinO_obj, LV_OBJ_FLAG_HIDDEN);
    } else {
        lv_obj_add_flag(icon_freinO_obj, LV_OBJ_FLAG_HIDDEN);
    }
    if (pcf8575_state & (1 << PCF8575_PIN_DEGIVRE)) {
        lv_obj_clear_flag(icon_degivre_obj, LV_OBJ_FLAG_HIDDEN);
    } else {
        lv_obj_add_flag(icon_degivre_obj, LV_OBJ_FLAG_HIDDEN);
    }
    if (pcf8575_state & (1 << PCF8575_PIN_ESSENCE)) {
        lv_obj_clear_flag(icon_essence_obj, LV_OBJ_FLAG_HIDDEN);
    } else {
        lv_obj_add_flag(icon_essence_obj, LV_OBJ_FLAG_HIDDEN);
    }
    if (pcf8575_state & (1 << PCF8575_PIN_PHARE)) {
        lv_obj_clear_flag(icon_phare_obj, LV_OBJ_FLAG_HIDDEN);
    } else {
        lv_obj_add_flag(icon_phare_obj, LV_OBJ_FLAG_HIDDEN);
    }
    if (pcf8575_state & (1 << PCF8575_PIN_PLEINPHARE)) {
        lv_obj_clear_flag(icon_pleinPhare_obj, LV_OBJ_FLAG_HIDDEN);
    } else {
        lv_obj_add_flag(icon_pleinPhare_obj, LV_OBJ_FLAG_HIDDEN);
    }
    if (pcf8575_state & (1 << PCF8575_PIN_CLIGNOTANT)) {
        lv_obj_clear_flag(icon_clignotant_obj, LV_OBJ_FLAG_HIDDEN);
    } else {
        lv_obj_add_flag(icon_clignotant_obj, LV_OBJ_FLAG_HIDDEN);
    }
}

// Fonction pour scanner les périphériques I2C
static void i2c_scan(void) {
    ESP_LOGI("I2C_STUFF", "Démarrage du scan I2C...");
    bool device_found = false;
    for (uint8_t addr = 0x08; addr <= 0x7F; addr++) {
        i2c_cmd_handle_t cmd = i2c_cmd_link_create();
        i2c_master_start(cmd);
        i2c_master_write_byte(cmd, (addr << 1) | I2C_MASTER_WRITE, true);
        i2c_master_stop(cmd);
        esp_err_t ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, I2C_TIMEOUT_MS / portTICK_PERIOD_MS);
        i2c_cmd_link_delete(cmd);

        if (ret == ESP_OK) {
            ESP_LOGI("I2C_STUFF", "Périphérique trouvé à l'adresse: 0x%02X", addr);
            device_found = true;
            if (addr == DS3231_I2C_ADDR) {
                ESP_LOGI("I2C_STUFF", "DS3231 détecté à l'adresse 0x%02X", addr);
            } else if (addr == PCF8575_I2C_ADDR) {
                ESP_LOGI("I2C_STUFF", "PCF8575 détecté à l'adresse 0x%02X", addr);
            }
        } else {
            ESP_LOGD("I2C_STUFF", "Aucun périphérique à l'adresse 0x%02X: %s", addr, esp_err_to_name(ret));
        }
    }
    if (!device_found) {
        ESP_LOGW("I2C_STUFF", "Aucun périphérique I2C détecté. Vérifiez SDA (GPIO%d) et SCL (GPIO%d).",
                 I2C_MASTER_SDA_IO, I2C_MASTER_SCL_IO);
    }
}

// Fonction pour initialiser l'I2C
static esp_err_t i2c_master_init(void) {
    ESP_LOGI("I2C_STUFF", "Initialisation I2C...");
    i2c_config_t conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = I2C_MASTER_SDA_IO,
        .scl_io_num = I2C_MASTER_SCL_IO,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = I2C_MASTER_FREQ_HZ,
    };
    esp_err_t ret = i2c_param_config(I2C_MASTER_NUM, &conf);
    if (ret != ESP_OK) {
        ESP_LOGE("I2C_STUFF", "Échec de la configuration I2C: %s", esp_err_to_name(ret));
        return ret;
    }
    ret = i2c_driver_install(I2C_MASTER_NUM, conf.mode, 0, 0, 0);
    if (ret != ESP_OK) {
        ESP_LOGE("I2C_STUFF", "Échec de l'installation du pilote I2C: %s", esp_err_to_name(ret));
        return ret;
    }
    ESP_LOGI("I2C_STUFF", "Bus I2C initialisé (SDA=GPIO%d, SCL=GPIO%d, freq=%d Hz)",
             I2C_MASTER_SDA_IO, I2C_MASTER_SCL_IO, I2C_MASTER_FREQ_HZ);
    return ESP_OK;
}


// Fonction pour convertir BCD en décimal
static uint8_t bcd_to_dec(uint8_t bcd) {
    return ((bcd >> 4) * 10) + (bcd & 0x0F);
}

// Fonction pour lire l'heure du DS3231
static esp_err_t ds3231_read_time(struct tm *timeinfo) {
    esp_err_t ret;
    uint8_t data[7]; // Buffer pour secondes, minutes, heures, jour, date, mois, année

    // Créer une commande I2C pour lire les registres 0x00 à 0x06
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (DS3231_I2C_ADDR << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, 0x00, true); // Commencer à l'adresse 0x00 (secondes)
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (DS3231_I2C_ADDR << 1) | I2C_MASTER_READ, true);
    i2c_master_read(cmd, data, 7, I2C_MASTER_LAST_NACK);
    i2c_master_stop(cmd);
    ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, I2C_TIMEOUT_MS / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);

    if (ret != ESP_OK) {
        ESP_LOGE("DS3231", "Échec de la lecture de l'heure: %s", esp_err_to_name(ret));
        return ret;
    }

    // Convertir les données BCD en décimal et remplir la structure tm
    timeinfo->tm_sec = bcd_to_dec(data[0]);
    timeinfo->tm_min = bcd_to_dec(data[1]);
    timeinfo->tm_hour = bcd_to_dec(data[2] & 0x3F); // Masquer les bits de format 24h/12h
    timeinfo->tm_mday = bcd_to_dec(data[4]);
    timeinfo->tm_mon = bcd_to_dec(data[5]) - 1; // tm_mon est de 0 à 11
    timeinfo->tm_year = bcd_to_dec(data[6]) + 2000 - 1900; // tm_year est années depuis 1900
    timeinfo->tm_wday = bcd_to_dec(data[3]) - 1; // Jour de la semaine (0-6, Dim-Sam)
    timeinfo->tm_isdst = -1; // Pas d'info sur l'heure d'été

    ESP_LOGI("DS3231", "Heure lue: %02d:%02d:%02d %02d/%02d/%04d",
             timeinfo->tm_hour, timeinfo->tm_min, timeinfo->tm_sec,
             timeinfo->tm_mday, timeinfo->tm_mon + 1, timeinfo->tm_year + 1900);

    return ESP_OK;
}

// Fonction pour synchroniser l'heure système avec le DS3231
static esp_err_t ds3231_sync_time(void) {
    struct tm timeinfo;
    esp_err_t ret = ds3231_read_time(&timeinfo);
    if (ret != ESP_OK) {
        return ret;
    }

    // Convertir struct tm en time_t
    time_t t = mktime(&timeinfo);
    if (t == -1) {
        ESP_LOGE("DS3231", "Échec de la conversion de l'heure");
        return ESP_FAIL;
    }

    // Mettre à jour l'heure système
    struct timeval tv = {
        .tv_sec = t,
        .tv_usec = 0
    };
    ret = settimeofday(&tv, NULL);
    if (ret != 0) {
        ESP_LOGE("DS3231", "Échec de la mise à jour de l'heure système");
        return ESP_FAIL;
    }

    ESP_LOGI("DS3231", "Heure système synchronisée avec le DS3231");
    return ESP_OK;
}

// Initialiser le PCF8575
static esp_err_t pcf8575_init(void) {
    ESP_LOGI("PCF8575", "Initialisation du PCF8575 à l'adresse 0x%02X", PCF8575_I2C_ADDR);
    // Pas besoin de configuration supplémentaire, le PCF8575 est prêt après la mise sous tension
    // On peut écrire un état initial (toutes les broches à 1 pour les entrées)
    uint16_t initial_state = 0xFFFF; // Toutes les broches à 1 (entrées ou sorties inactives)
    esp_err_t ret = pcf8575_write(initial_state);
    if (ret != ESP_OK) {
        ESP_LOGE("PCF8575", "Échec de l'initialisation: %s", esp_err_to_name(ret));
    }
    return ret;
}

// Écrire sur les broches du PCF8575
static esp_err_t pcf8575_write(uint16_t value) {
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, PCF8575_WRITE_ADDR, true);
    i2c_master_write_byte(cmd, (value & 0xFF), true); // Octet bas
    i2c_master_write_byte(cmd, (value >> 8), true);   // Octet haut
    i2c_master_stop(cmd);
    esp_err_t ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, I2C_TIMEOUT_MS / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);
    if (ret != ESP_OK) {
        ESP_LOGE("PCF8575", "Échec de l'écriture: %s", esp_err_to_name(ret));
    }
    return ret;
}

// Lire les broches du PCF8575
static esp_err_t pcf8575_read(uint16_t *value) {
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, PCF8575_READ_ADDR, true);
    uint8_t low_byte, high_byte;
    i2c_master_read_byte(cmd, &low_byte, I2C_MASTER_ACK);
    i2c_master_read_byte(cmd, &high_byte, I2C_MASTER_NACK);
    i2c_master_stop(cmd);
    esp_err_t ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, I2C_TIMEOUT_MS / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);
    if (ret == ESP_OK) {
        *value = (high_byte << 8) | low_byte;
    } else {
        ESP_LOGE("PCF8575", "Échec de la lecture: %s", esp_err_to_name(ret));
    }
    return ret;
}

// Fonction pour calculer la position de l'aiguille des heures
void get_hour_hand_end(int hour, int minute, int center_x, int center_y, int length, lv_point_t *point) {
    float hour_angle = (hour % 12) * 30.0f + (minute / 60.0f) * 30.0f;
    float hour_angle_rad = hour_angle * (M_PI / 180.0f) - M_PI / 2.0f;
    point->x = center_x + length * cosf(hour_angle_rad);
    point->y = center_y + length * sinf(hour_angle_rad);
}

// Fonction pour calculer la position de l'aiguille des minutes
void get_minute_hand_end(int minute, int second, int center_x, int center_y, int length, lv_point_t *point) {
    float minute_angle = minute * 6.0f + (second / 60.0f) * 6.0f;
    float minute_angle_rad = minute_angle * (M_PI / 180.0f) - M_PI / 2.0f;
    point->x = center_x + length * cosf(minute_angle_rad);
    point->y = center_y + length * sinf(minute_angle_rad);
}

// Fonction pour calculer la position de l'aiguille des secondes
/*void get_second_hand_end(int second, int center_x, int center_y, int length, lv_point_t *point) {
    float second_angle = second * 6.0f;
    float second_angle_rad = second_angle * (M_PI / 180.0f) - M_PI / 2.0f;
    point->x = center_x + length * cosf(second_angle_rad);
    point->y = center_y + length * sinf(second_angle_rad);
}*/

// Fonction pour calculer la position de l'aiguille des secondes
void get_second_hand_end(int second, int millisecond, int center_x, int center_y, int length, lv_point_t *point) {
    float second_angle = second * 6.0f + (millisecond / 1000.0f) * 6.0f;
    float second_angle_rad = second_angle * (M_PI / 180.0f) - M_PI / 2.0f;
    point->x = center_x + length * cosf(second_angle_rad);
    point->y = center_y + length * sinf(second_angle_rad);
}

// Fonction pour dessiner la montre
// Fonction pour dessiner la montre
void draw_clock(clock_hands_t *hands) {
    // Obtenir l'heure actuelle pour le jour du mois
    struct timeval tv_now;
    gettimeofday(&tv_now, NULL);
    time_t now = tv_now.tv_sec;
    struct tm *timeinfo = localtime(&now);
    int day = timeinfo->tm_mday;

    // Mettre à jour l'étiquette de la date uniquement si le jour a changé
    if (day != last_day) {
        char date_str[3];
        snprintf(date_str, sizeof(date_str), "%d", day);
        lv_label_set_text(date_label, date_str);
        last_day = day; // Mémoriser le nouveau jour
        ESP_LOGI("CLOCK", "Date mise à jour : %s", date_str);
    }

    // Effacer le canvas
    lv_canvas_fill_bg(theCanvas, lv_color_hex(0x000000), LV_OPA_TRANSP); // Fond transparent
    

    // Dessiner le cadran (cercle)
    lv_draw_arc_dsc_t arc_dsc;
    lv_draw_arc_dsc_init(&arc_dsc);
    arc_dsc.color = lv_color_white();
    arc_dsc.width = 2;
    lv_canvas_draw_arc(theCanvas, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, CLOCK_RADIUS, 0, 360, &arc_dsc);

    // Dessiner les marqueurs des heures (toutes les 5 minutes)
    for (int i = 0; i < 60; i++) {
        float angle = i * 6.0f * (M_PI / 180.0f) - M_PI / 2.0f;
        int length = (i % 5 == 0) ? 10 : 5; // Marqueurs plus longs pour les heures
        lv_point_t outer = {
            CANVAS_WIDTH / 2 + CLOCK_RADIUS * cosf(angle),
            CANVAS_HEIGHT / 2 + CLOCK_RADIUS * sinf(angle)
        };
        lv_point_t inner = {
            CANVAS_WIDTH / 2 + (CLOCK_RADIUS - length) * cosf(angle),
            CANVAS_HEIGHT / 2 + (CLOCK_RADIUS - length) * sinf(angle)
        };
        lv_draw_line_dsc_t line_dsc;
        lv_draw_line_dsc_init(&line_dsc);
        line_dsc.color = lv_color_white();
        line_dsc.width = (i % 5 == 0) ? 3 : 1;
        lv_point_t points[2] = {inner, outer};
        lv_canvas_draw_line(theCanvas, points, 2, &line_dsc);
    }

    // Ajouter les numéros des heures (1 à 12)
    lv_draw_label_dsc_t label_dsc;
    lv_draw_label_dsc_init(&label_dsc);
    label_dsc.color = lv_color_white();
    label_dsc.font = &lv_font_montserrat_16; // Utiliser une police disponible
    label_dsc.align = LV_TEXT_ALIGN_CENTER;

    for (int i = 1; i <= 12; i++) {
        float angle = (i * 30.0f - 90.0f) * (M_PI / 180.0f); // -90 pour commencer à 12h
        // Positionner les chiffres légèrement à l'intérieur du cadran
        int text_radius = CLOCK_RADIUS - 20; // Ajuster pour placer les chiffres
        int x = CANVAS_WIDTH / 2 + text_radius * cosf(angle);
        int y = CANVAS_HEIGHT / 2 + text_radius * sinf(angle);

        char num_str[3];
        snprintf(num_str, sizeof(num_str), "%d", i);
        lv_canvas_draw_text(theCanvas, x - 10, y - 10, 20, &label_dsc, num_str);
    }

    // Dessiner l'aiguille des heures
    lv_draw_line_dsc_t hour_dsc;
    lv_draw_line_dsc_init(&hour_dsc);
    hour_dsc.color = lv_color_white();
    hour_dsc.width = 6;
    lv_point_t hour_points[2] = {{CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2}, hands->hour_end};
    lv_canvas_draw_line(theCanvas, hour_points, 2, &hour_dsc);

    // Dessiner l'aiguille des minutes
    lv_draw_line_dsc_t minute_dsc;
    lv_draw_line_dsc_init(&minute_dsc);
    minute_dsc.color = lv_color_white();
    minute_dsc.width = 4;
    lv_point_t minute_points[2] = {{CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2}, hands->minute_end};
    lv_canvas_draw_line(theCanvas, minute_points, 2, &minute_dsc);

    // Dessiner l'aiguille des secondes
    lv_draw_line_dsc_t second_dsc;
    lv_draw_line_dsc_init(&second_dsc);
    second_dsc.color = lv_color_hex(0xff0000);
    second_dsc.width = 2;
    lv_point_t second_points[2] = {{CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2}, hands->second_end};
    lv_canvas_draw_line(theCanvas, second_points, 2, &second_dsc);

    // Dessiner le centre de la montre
    lv_draw_arc_dsc_t center_dsc;
    lv_draw_arc_dsc_init(&center_dsc);
    center_dsc.color = lv_color_white();
    lv_canvas_draw_arc(theCanvas, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 5, 0, 360, &center_dsc);
}


// Fonction de mise à jour de la montre (appelée par le timer)
static void clock_timer_cb2() {
    // Lire l'état des broches du PCF8575
    uint16_t pcf8575_state = 0;
    esp_err_t ret = pcf8575_read(&pcf8575_state);
    if (ret != ESP_OK) {
        ESP_LOGE("PCF8575", "Erreur de lecture des broches: %s", esp_err_to_name(ret));
        pcf8575_state = 0; // Valeur par défaut en cas d'erreur
    }/* else {
        ESP_LOGI("PCF8575", "État des broches: 0x%04X", pcf8575_state); // Log pour débogage
    }*/

    // Mettre à jour les icônes
    update_dashboard_icons(pcf8575_state);

    // Obtenir l'heure actuelle
    struct timeval tv_now;
    gettimeofday(&tv_now, NULL);

    // Obtenir l'heure actuelle
    time_t now = tv_now.tv_sec;
    struct tm *timeinfo = localtime(&now);
    int hour = timeinfo->tm_hour;
    int minute = timeinfo->tm_min;
    int second = timeinfo->tm_sec;
    int millisecond = tv_now.tv_usec / 1000;

    // Calculer les positions des aiguilles
    clock_hands_t hands;
    get_hour_hand_end(hour, minute, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, HOUR_HAND_LENGTH, &hands.hour_end);
    get_minute_hand_end(minute, second, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, MINUTE_HAND_LENGTH, &hands.minute_end);
    //get_second_hand_end(second, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, SECOND_HAND_LENGTH, &hands.second_end);
    get_second_hand_end(second, millisecond, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, SECOND_HAND_LENGTH, &hands.second_end);

    // Dessiner la montre
    draw_clock(&hands);

    //debug
    //ESP_LOGI("PCF8575", "État des broches: 0x%04X", pcf8575_state);
}

// Fonction d'initialisation de la montre
void clock_init(void) {
    // Allouer le buffer pour le canvas de fond dans la PSRAM
    size_t bg_buf_size = LV_CANVAS_BUF_SIZE_TRUE_COLOR(FULL_CANVAS_WIDTH, FULL_CANVAS_HEIGHT) * sizeof(lv_color_t);
    bg_cbuf = (lv_color_t *)heap_caps_malloc(bg_buf_size, MALLOC_CAP_SPIRAM);
    if (bg_cbuf == NULL) {
        ESP_LOGE("CLOCK", "Échec de l'allocation du buffer de fond dans la PSRAM");
        return;
    }

    // Créer le canvas de fond
    background_canvas = lv_canvas_create(lv_scr_act());
    lv_canvas_set_buffer(background_canvas, bg_cbuf, FULL_CANVAS_WIDTH, FULL_CANVAS_HEIGHT, LV_IMG_CF_TRUE_COLOR);
    lv_obj_align(background_canvas, LV_ALIGN_CENTER, 0, 0);
    lv_canvas_fill_bg(background_canvas, lv_color_hex(0x009A76), LV_OPA_COVER); // Fond de la même couleur que l'écran

    // Allouer le buffer pour le canvas de l'horloge avec lv_mem_alloc
    size_t buf_size = LV_CANVAS_BUF_SIZE_TRUE_COLOR_ALPHA(CANVAS_WIDTH, CANVAS_HEIGHT) * sizeof(lv_color_t);
    cbuf = (lv_color_t *)lv_mem_alloc(buf_size);
    if (cbuf == NULL) {
        ESP_LOGE("CLOCK", "Échec de l'allocation du buffer dans la PSRAM");
        heap_caps_free(bg_cbuf);
        return;
    }

    // Initialize the buffer to transparent
    memset(cbuf, 0, buf_size);

    if (esp_psram_is_initialized()) {
        init_icon_battery();
        init_icon_huile();
        init_icon_freinR();
        init_icon_freinO();
        init_icon_degivre();
        init_icon_essence();
        init_icon_phare();
        init_icon_pleinPhare();
        init_icon_clignotant();
    } else {
        ESP_LOGE("CLOCK", "PSRAM not available for icons");
    }

    // Créer la fenêtre de date (rectangle)
    date_window = lv_obj_create(background_canvas);
    lv_obj_set_size(date_window, 40, 24); // Taille de la fenêtre
    lv_obj_set_pos(date_window, FULL_CANVAS_WIDTH / 2 + 80, FULL_CANVAS_HEIGHT / 2 - 12); // Position à 3h
    lv_obj_set_style_bg_color(date_window, lv_color_hex(0x000000), LV_PART_MAIN); // Fond noir
    lv_obj_set_style_border_color(date_window, lv_color_white(), LV_PART_MAIN); // Bordure blanche
    lv_obj_set_style_border_width(date_window, 1, LV_PART_MAIN);
    lv_obj_set_style_radius(date_window, 4, LV_PART_MAIN); // Coins arrondis

    // Créer l'étiquette pour le jour du mois
    date_label = lv_label_create(date_window);
    lv_label_set_text(date_label, "1"); // Valeur initiale
    lv_obj_align(date_label, LV_ALIGN_CENTER, 0, 0); // Centrer dans la fenêtre
    lv_obj_set_style_text_color(date_label, lv_color_white(), LV_PART_MAIN);
    lv_obj_set_style_text_font(date_label, &lv_font_montserrat_16, LV_PART_MAIN);

    // Create image objects
    icon_battery_obj = lv_img_create(background_canvas);
    lv_img_set_src(icon_battery_obj, &icon_battery);
    lv_obj_set_pos(icon_battery_obj, 0, 1); // Top-left
    lv_obj_add_flag(icon_battery_obj, LV_OBJ_FLAG_HIDDEN); // Hidden by default

    // Create image objects
    icon_huile_obj = lv_img_create(background_canvas);
    lv_img_set_src(icon_huile_obj, &icon_huile);
    lv_obj_set_pos(icon_huile_obj, 0, 34*1+1); // Top-left
    lv_obj_add_flag(icon_huile_obj, LV_OBJ_FLAG_HIDDEN); // Hidden by default


    // Create image objects
    icon_freinR_obj = lv_img_create(background_canvas);
    lv_img_set_src(icon_freinR_obj, &icon_freinR);
    lv_obj_set_pos(icon_freinR_obj, 0, 34*2+1); // Top-left
    lv_obj_add_flag(icon_freinR_obj, LV_OBJ_FLAG_HIDDEN); // Hidden by default


    // Create image objects
    icon_freinO_obj = lv_img_create(background_canvas);
    lv_img_set_src(icon_freinO_obj, &icon_freinO);
    lv_obj_set_pos(icon_freinO_obj, 0, 34*3+1); // Top-left
    lv_obj_add_flag(icon_freinO_obj, LV_OBJ_FLAG_HIDDEN); // Hidden by default

    // Create image objects
    icon_essence_obj = lv_img_create(background_canvas);
    lv_img_set_src(icon_essence_obj, &icon_essence);
    lv_obj_set_pos(icon_essence_obj, 0, 34*4+1); // Top-left
    lv_obj_add_flag(icon_essence_obj, LV_OBJ_FLAG_HIDDEN); // Hidden by default

    // Create image objects
    icon_degivre_obj = lv_img_create(background_canvas);
    lv_img_set_src(icon_degivre_obj, &icon_degivre);
    lv_obj_set_pos(icon_degivre_obj, 0, 34*5+1); // Top-left
    lv_obj_add_flag(icon_degivre_obj, LV_OBJ_FLAG_HIDDEN); // Hidden by default

    // Create image objects
    icon_clignotant_obj = lv_img_create(background_canvas);
    lv_img_set_src(icon_clignotant_obj, &icon_clignotant);
    lv_obj_set_pos(icon_clignotant_obj, 400, 1); // Top-left
    lv_obj_add_flag(icon_clignotant_obj, LV_OBJ_FLAG_HIDDEN); // Hidden by default

    // Create image objects
    icon_phare_obj = lv_img_create(background_canvas);
    lv_img_set_src(icon_phare_obj, &icon_phare);
    lv_obj_set_pos(icon_phare_obj, 400, 34*1+1); // Top-left
    lv_obj_add_flag(icon_phare_obj, LV_OBJ_FLAG_HIDDEN); // Hidden by default

    // Create image objects
    icon_pleinPhare_obj = lv_img_create(background_canvas);
    lv_img_set_src(icon_pleinPhare_obj, &icon_pleinPhare);
    lv_obj_set_pos(icon_pleinPhare_obj, 400, 34*2+1); // Top-left
    lv_obj_add_flag(icon_pleinPhare_obj, LV_OBJ_FLAG_HIDDEN); // Hidden by default





    // Créer un canvas
    theCanvas = lv_canvas_create(lv_scr_act());
    lv_canvas_set_buffer(theCanvas, cbuf, CANVAS_WIDTH, CANVAS_HEIGHT, LV_IMG_CF_TRUE_COLOR_ALPHA);
    lv_obj_align(theCanvas, LV_ALIGN_CENTER, 0, 0);
    lv_canvas_fill_bg(theCanvas, lv_color_hex(0x000000), LV_OPA_TRANSP); // Fond transparent

    // Dessiner la montre initialement
    clock_timer_cb2();
}


void setup(void){
    bsp_display_cfg_t cfg = {
        .lvgl_port_cfg = ESP_LVGL_PORT_INIT_CONFIG(),
        .buffer_size = EXAMPLE_LCD_QSPI_H_RES * EXAMPLE_LCD_QSPI_V_RES,
  #if LVGL_PORT_ROTATION_DEGREE == 90
        .rotate = LV_DISP_ROT_90,
  #elif LVGL_PORT_ROTATION_DEGREE == 270
        .rotate = LV_DISP_ROT_270,
  #elif LVGL_PORT_ROTATION_DEGREE == 180
        .rotate = LV_DISP_ROT_180,
  #elif LVGL_PORT_ROTATION_DEGREE == 0
        .rotate = LV_DISP_ROT_NONE,
  #endif
    };
  
    bsp_display_start_with_config(&cfg);
    bsp_display_backlight_on();
    bsp_display_brightness_set(10);
    lv_obj_set_style_bg_color(lv_scr_act(), lv_color_hex(0x009A76), LV_PART_MAIN);
    ESP_LOGI(TAG, "Create UI");
    /* Lock the mutex due to the LVGL APIs are not thread-safe */
    bsp_display_lock(0);
  
    bsp_display_unlock();
    lv_timer_handler();

}

// Point d'entrée pour ESP32 (exemple pour ESP-IDF)
void app_main(void) {
    // Vérifier que la PSRAM est disponible
    if (esp_psram_is_initialized()) {
        ESP_LOGI(TAG, "PSRAM initialisée, taille: %zu bytes", esp_psram_get_size());
    } else {
        ESP_LOGE(TAG, "Échec de l'initialisation de la PSRAM");
    }

    // Initialiser l'I2C pour le DS3231
    esp_err_t ret = i2c_master_init();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Échec de l'initialisation I2C: %s", esp_err_to_name(ret));
        return;
    }
    
    // Scanner les périphériques I2C pour détecter le DS3231
    i2c_scan();

    // Initialiser le PCF8575
    ret = pcf8575_init();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Échec de l'initialisation du PCF8575");
    }

    // Synchroniser l'heure avec le DS3231
    ret = ds3231_sync_time();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Échec de la synchronisation de l'heure avec DS3231");
    }



    // Initialiser LVGL et le pilote d'affichage (à configurer selon votre écran)
    //lv_init();
    setup();
    // Configurer votre pilote d'affichage ici (par exemple, ILI9341, ST7789)
    // Exemple : lvgl_driver_init(); (dépend de votre configuration)

    // Initialiser la montre
    clock_init();

    // Boucle principale
    while (1) {
        bsp_display_lock(0);
        clock_timer_cb2();
        lv_timer_handler();
        bsp_display_unlock();
        vTaskDelay(100 / portTICK_PERIOD_MS);

        // Resynchroniser toutes les 3600 secondes (1 heure)
        static uint32_t last_sync = 0;
        uint32_t current_time = esp_log_timestamp() / 1000; // Temps en secondes
        if (current_time - last_sync >= 3600) {
            esp_err_t ret = ds3231_sync_time();
            if (ret == ESP_OK) {
                ESP_LOGI("DS3231", "Resynchronisation périodique réussie");
            } else {
                ESP_LOGE("DS3231", "Échec de la resynchronisation");
            }
            last_sync = current_time;
        }
    }

    // Libérer le buffer à la fin (optionnel)
    if (cbuf != NULL) {
        heap_caps_free(cbuf);
    }
}